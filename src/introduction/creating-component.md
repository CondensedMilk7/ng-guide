# კომპონენტის შექმნა და კონფიგურაცია

ფრეიმვორქის ერთ-ერთი უპირატესობა ის არის, რომ შეგვიძლია აპლიკაცია დავყოთ კომპონენტებად.
ეს საშუალებას გვაძლევს, რომ აპლიკაციის განმეორებადი ელემენტები ერთ ადგილას განვსაზღვროთ
და ბევრგან გამოვიყენოთ.

**შენიშვნა:** ამ თავში განვიხილავთ NgModule-ზე დამოკიდებულ კომპონენტებს. ანგულარში
მე-14 ვერსიდან შესაძლებელია "standalone" კომპონენტების შექმნაც, რომლებიც ოდნავ
განსხვავებულად მუშაობენ. რეკომენდირებულია, რომ ჯერ აქ ახსნილ მიდგომას გაეცნოთ,
სხვა ფუნდამენტებიც ისწავლოთ და შემდგომ [გაეცნოთ standalone კომპონენტებს](../standalone/).

ანგულარის კომპონენტი ჩვეულებრივ სამ ფაილად დაყოფილი ფოლდერია. გვაქვს ts ფაილი, სადაც
კომპონენტის კონფიგურაცია და ჯავასკრიპტის ლოგიკა ერთიანდება, html თემფლეითი, სადაც კომპონენტის
მარკაპია და scss/css ფაილი, სადაც კომპონენტის სტილებია.

```
# example კომპონენტი

example.component.ts
example.component.html
example.component.scss
```

ახალი კომპონენტის შემოტანა ასეთი ფაილების ხელით შექმნით შეიძლება, ან უბრალოდ CLI-ში ბრძანების გაშვებით:

```
ng generate component child
```

child იქნება ის სახელი, რომელსაც კომპონენტს დავარქმევთ.
ანგულარი შექმნის კომპონენტს, რომელიც განთავსდება child სახელის მქონე ფოლდერში.
ფაილების დასახელება მათი დანიშნულების მიხედვით ხდება. კონვენციურად წერტილებით
გამოიყოფა `component` ფაილების დასახელებაში. html ფაილში ჩვენ ვწერთ მარკაპს.
ანგულარის CLI-იმ წინასწარ თემფლეითში ჩაგვისვა ტექსტი, რომელიც კომპონენტის სადმე
განთავსების შემთხვევაში უნდა გამოჩნდეს.
scss ფაილში სტილებს ვწერთ ამ კომპონენტის სტილებს, ხოლო ts ფაილში კომპონენტის ლოგიკას.
როგორ არის ეს ყველაფერი ერთმანეთთან დაკავშირებული?

ტაიპსკრიპტის ფაილში ვხედავთ, რომ დაესქპორტებულია კომპონენტის კლასი, რომელსაც
კონვენციურად სახელთან ერთად ეწერება სიტყვა 'Component', მაგრამ კლასის
დაექსპორტებამდე მას თან ახლავს `@angular/core`-დან დაიმპორტებული `@Component` დეკორატორი.
დეკორატორი ტაიპსკრიპტის
ხელსაწყოა, რომელიც მეტაპროგრამირებაში გამოიყენება. იგი ერთგვარი ფუნქციაა, რომელიც
მოდიფიკაციას უკეთებს მონაცემის სტრუქტურას - ამ შემთხვევაში კომპონენტის კლასს.
ამ დეკორატორში კონფიგურაციის ობიექტის მიწოდებით ანგულარი მუშა კომპონენტის ინსტანციას ქმნის.

```ts
import { Component } from "@angular/core";

@Component({
  selector: "app-child",
  templateUrl: "./child.component.html",
  styleUrls: ["./child.component.scss"],
})
export class ChildComponent {}
```

`selector` არის ის თეგი, რომლითაც ამ კომპონენტს თემფლეითში განვათავსებთ.
კონვენციურად კომპონენტის თეგებს აქვთ `app` პრეფიქსი, მაგრამ ეს შეიძლება იყოს
პროექტის დასახელება, კომპანიის სახელი, რომელიმე მათგანის აბრივიაცია და ა.შ.
სცადეთ `app.component.html`-ში ამ თეგის განთავსება:

```html
<!-- must be opening and closing tags -->
<app-child></app-child>
```

თუ სადეველოპმენტო სერვერი გაშვებული გაქვთ, მაშინ ის მარკაპი უნდა დავინახოთ,
რომელიც `child.component.html`-ში დავწერეთ.

კონფიგურაციაში `templateUrl` მიუთითებს იმ მისამართზე, სადაც თეფლეითის ფაილი
უნდა იყოს. იგივე ეხება `styleUrls`-საც, თუმცა აქ მნიშვნელობებს მასივში ვაწვდით,
რადგან სტილების ფაილი ერთზე მეტი შეიძლება გვქონდეს.

ამ კონფიგურაციას ანგულარის ქომფაილერი კითხულობს, თუმცა კომპონენტის არსებობა
მისთვის ცნობილი არ იქნებოდა, ამ კომპონენტის ფაილების შექმნისას, ტაიპსკრიპტის
ფაილში დაექსპორტებული (და დეკორატორით გონფიგურირებული) კლასი `app.module.ts`-ში
რომ არ შეგვეტანა, დეკლარაციების მასივში.

```ts
import { NgModule } from "@angular/core";
import { BrowserModule } from "@angular/platform-browser";

import { AppComponent } from "./app.component";
import { ChildComponent } from "./child/child.component";

@NgModule({
  declarations: [AppComponent, ChildComponent],
  imports: [BrowserModule],
  providers: [],
  bootstrap: [AppComponent],
})
export class AppModule {}
```

ეს ანგულარის CLI-იმ ჩვენ მაგივრად გააკეთა, თუმცა თუ კომპონენტის ფაილებს ხელით ვქმნით,
მისი მოდულის ფაილში დაიმპორტება და დეკლარაციების მასივში დამატება არ უნდა დაგვავიწყდეს.

აღსანიშნავია, რომ `@Component` დეკორატორში `templateUrl`-ის მაგივრად შეგვიძლია გამოვიყენოთ
`template` და მარკაპი პირტაპირ ამ თვისების მნიშვნელობაში ჩავწეროთ, როგორც სტრინგი:

```ts
@Component({
  selector: 'app-child',
  template: `<h1>Hello from ChildComponent!</h1>`,
  styleUrls: ["./child.component.scss"],
})
```

ასევე შეგვიძლია styles თვისების გამოყენება styleUrls-ის მაგივრად, და მასივში სტრინგების მიწოდება,
სადაც ჩვენ მიერ არჩეული სტილების ფაილის სინტაქსი იმუშავებს:

```ts
@Component({
  selector: 'app-child',
  template: `<h1>Hello from ChildComponent!</h1>`,
  styles: [
    `
    h1 {
      color: red;
    }
    `
  ],
})
```

`@Component` დეკორატორის დანიშნულება ამით არ ამოიწურება. მის შესახებ დეტალური ინფორმაციისთვის
[გაეცანით ოფიციალურ დოკუმენტაციას](https://angular.io/api/core/Component).
