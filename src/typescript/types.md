# ტიპები

## Type Inference

ტიპი აღწერს მონაცემის თავისებურებას. ჩვეულებრივ, ტაიპსკრიპტი თავისით ამოიცნობს ტიპებს
(type inference) და ჩვენ ყოველთვის არ გვჭირდება ექსპლიციტურად ტიპების განსაზღვრა.

```ts
const myStr = "hello"; // string
const anotherStr = "1234"; // string
const myNum = 74; // number
const anotherNum = -12.54; // number
let myBool = true; // boolean

function greet() {
  return "Hello there!"; // ტაიპსკრიპტი მიხვდება, რომ ფუნქცია string-ს აბრუნებს
}

myBool = "a string"; // ეს გამოიწვევს ერორს, რადგან boolean ტიპის ცვლადში ვინახავთ string-ს.
```

რადგან ჩვენ თავიდან `myBool` ცვლადი შევქმენით `boolean` ტიპით, ტაიპსკრიპტი უფლებას არ გვაძლევს,
რომ ამ ცვლადში შემდგომ სხვა ტიპის მნიშვნელობა შევინახოთ.

იგივე ეხება ობიექტებს:

```ts
const user = {
  id: 588,
  name: "John",
};

user.id = "98"; // გამოიწვევს ერორს, რადგან user.id უნდა იყოს number და არა string
```

მასივების შემთხვევაში მისი ელემენტების ტიპი ავტომატურად არის any, რაც ნებისმიერ ტიპს ნიშნავს,
ამიტომ მათი შეცვლა ერორს არ გამოიწვევს.

## ექსპლიციტური ტიპები

ჩვენ ტიპების განსაზღვრა შეგვიძლია დეკლარაციის დროს.

```ts
const typescript: string = "cool"; // ცვლადი მხოლოდ string იქნება
let myBool: boolean; // ცვლადი მხოლოდ boolean იქნება

if (typescript === "cool") {
  myBool = true; // ვალიდურია
}

let fluidVar: any = "hello";
fluidVar = 99;
fluidVar = false;
fluidVar = { name: "john" };
```

`any` ტიპი გულისხმობს ნებისმიერ ტიპს. ასეთი ტიპის წყალობით ტაიპსკრიპტი არანაირ მნიშვნელობაზე
არ გამოაცხადებს პრეტენზიას.

მასივების შემთხვევაში უნდა მივუთითოთ რა ტიპის ელემენტები იქნება მასში.

```ts
const myArr: string[] = ["one"];

myArr.push("two");
myArr.push(3); // გამოიწვევს ერორს
```

ასე ჩვენ დეკლარაციას ვუკეთებთ მასივს, რომელშიც მხოლოდ სტრინგის ტიპის მნიშვნელობები იქნება.

ფუნქციებში შეგვიძლია განვსაზღვროთ პარამეტრის ტიპები და დაბრუნებული შედეგის ტიპი:

```ts
function multiply(a: number, b: number): number {
  return a * b;
}

multiply(12, "wrong"); // გამოიწვევს ერორს, რადგან b არგუმენტად არ ვაწვდით number ტიპს
```

აღსანიშნავია, რომ ფუნქციის დაბრუნებულ ტიპს ტაიპსკრიპტი ისედაც მიხვდება, თუ მას ჩვენ
ექსპლიციტურად არ დავუწერთ, მაგრამ ხშირად ჯობია, რომ ტიპები მივუთითოთ.

შეგვიძლია ფუნქციის ტიპები არასავალდებულო გავხადოთ `?` სიმბოლოს გამოყენებით:

```ts
function log(text?: number): void {
  if (text) {
    console.log(text);
  } else {
    console.log("No text was provided");
  }
}

log(); // არ გამოიწვევს ერორს და ამობეჭდავს "No text was provided".
```

რამდენიმე პარამეტრის შემთხვევაში, არასავალდებულო პარამეტრები აუცილებლად უნდა იყოს
ბოლოში.

## Union Types

შესაძლებელია ტიპების გაერთიანება `|` სიმბოლოთი:

```ts
let myVar: string | number | { id: number } = 85;

myVar = { id: 999 }; // ვალიდურია
myVar = { name: "John", lastName: "Doe" }; // გამოიწვევს ერორს
```

ჩვენ დეკლარაციას ვუკეთებთ ცვლადს, რომელიც შეიძლება იყოს string, number ან ობიექტი,
რომლის თვისებაც არის id რიცხვის ტიპით.

## Interface

ჩვენ შეგვიძლია ობიექტის სტრუქტურის ექსპლიციტურად აღწერა ინტერფეისის საშუალებით:

```ts
interface User {
  name: string;
  id: number;
  email?: string;
}

const someUser: User = {
  name: "John",
  id: 0,
  // email-ის არ არსებობა არ გამოიწვევს ერორს.
};
```

`interface` გასაღებით განვსაზღვრეთ `User` ტიპი, რომელიც კონვენციურად
"UpperCamelCase"-ით იწერება, როგორც კლასი. ამ ინტერფეისში შემდგომ
ჩამოწერილია ცალკეული თვისებების ტიპები. ნებისმიერი ცვლადი, რომლის
ტიპიც იქნება `User`, ამ სტრუქტურას უნდა დაემორჩილოს. `?` სიმბოლოთი
აღწერილი ტიპები არის არასავალდებული - მათი არ არსებობის შემთხვევაში
ერორი არ მოხდება, ტუმცა მათი შექმნის შემთხვევაში, აუცილებელია, რომ
სწორი ტიპის მნიშვნელობა შევქმნათ.

შესაძლებელია ინტერფეისების (ან კლასების) გავრცობა სხვა ინტერფეისებით,
`extends` გასაღების მეშვეობით:

```ts
interface User {
  name: string;
  id: number;
  email?: string;
}

interface Admin extends User {
  canEdit: boolean;
}

const admin: Admin = {
  name: "John",
  id: 0,
  canEdit: true,
};
```

`Admin` ინტერფეისი `User` ინტერფეისისგან მიიღებს თვისებების ტიპებს და თავის მხრივ
ახალი თვისებების ტიპებითაც იხელმძღვაბელებს. მაშასადამე ცვლადს, რომელიც `Admin`
ტიპის იქნება, დასჭირდება არა მხოლოდ Admin-ის ინტერფეისში არსებული ტიპის თვისებები,
არამედ `User`-ში არსებული ტიპის თვისებებიც (არასავალდებულო ტიპების გამოკლებით).

## Tuples

თუფლები გამოიყენება მასივებში კონკრეტულ ინდექსებზე არსებული ელემენტების
ტიპის განსაზღვრისთვის. მოცემულ მაგალითში 0 ინდექსზე ყოველთვის იქნება
`number`, 1-ზე `string`, ხოლო 2-ზე `boolean` ტიპის მნიშვნელობები.

```ts
let myTuple: [number, string, boolean] = [4, "Tuple this, tuple that", true];

myTuple[1] = false; // გამოიწვევს ერორს, რადგან string-ს ვანაცვლებთ boolean-ით.
```

როგორც მასივების შემთხვევაშია, შესაძლებელია თუფლების დესტრუქტურიზაციაც. ახალი
ცვლადები შესაბამის ტიპებს მიიღებენ.

```ts
let myTuple: [number, string, boolean] = [4, "Tuple this, tuple that", true];

const [a, b, c] = myTuple;
```

a ცვლადი იქნება number, b ცვლადი იქნება string, ხოლო c იქნება boolean.
