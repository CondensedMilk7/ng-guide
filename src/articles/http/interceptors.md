---
title: "ინტერცეპტორები"
---

# ინტერცეპტორები

ინტერცეპტორი (interceptor) წარმოადგენს ე.წ middlware-ს, რომელიც HTTP მოთხოვნებთან დაკავშირებულ
განმეორებად ოპერაციებს ამარტივებს. ეს ოპერაციები შეიძლება იყოს მოთხოვნის ხელახლა გაგზავნა,
ქეშირება, ლოგების აღრიცხვა და ავთენტიკაცია.

## ინტერცეპტორის შექმნა

ინტერცეპტორის ელემენტარული ფორმა არის ფუნქცია, რომელიც პარამეტრებში იღებს გამავალ `HttpRequest`-სა (`req` პარამეტრი) და `HttpHandlerFn`-ს (`next` პარამეტრი). ეს უკანასკნელი
წარმოადგენს მოთხოვნის გადამუშავების შემდეგ ნაბიჯს ინტერცეპტორების ჯაჭვში.
ეს იმას ნიშნავს, რომ ერთი და იმავე მოთხოვნის დამუშავება შესაძლებელია თანმიმდევრულად რამდენიმე
ინტერცეფტორით.

ჩვეულებრივ ინტერცეფტორის ფაილი იქმნება `.interceptor.ts` დაბოლოებით, მაგალითად `logging.interceptor.ts`.

```ts
export function loggingInterceptor(
  req: HttpRequest<unknown>,
  next: HttpHandlerFn
): Observable<HttpEvent<unknown>> {
  console.log(req.url);
  return next(req);
}
```

აქ ვიღებთ მოთხოვნას და მის `url` თვისებას ვლოგავთ კონსოლში,
ხოლო შემდეგ `next` მეთოდზე დაძახებას ვაბრუნებთ, რათა მოთხოვნა შემდეგ ინტერცეპტორს გადაეცეს.

იმისთვის რომ ინტერცეპტორმა იმუშაოს, საჭიროა `HttpClient`-ის კონფიგურაცია.

## ინტერცეპტორების კონფიგურაცია

გამოსაყენებელ ინტერცეპტორებს ვაცხადებთ `HttpClient`-ის პროვაიდერად მიწოდებისას,
ანუ `provideHttpClient`-ში, რომელსაც არგუმენტად ვაწვდით `withInterceptors` ფუნქციას.
ამ ფუნქციაში შეგვიძლია ჩვენი ინტერცეპტორების მასივის ჩამოწერა.

```ts
bootstrapApplication(AppComponent, {
  providers: [
    provideHttpClient(
      withInterceptors([loggingInterceptor, cachingInterceptor])
    ),
  ],
});
```

ინტერცეპტორები ჯაჭვში იმ თანმიმდევრობით იმუშავებენ, რა თანმიმდევრობითაც პროვაიდერებში ჩამოვთვლით.
შესაბამისად აქ მოთხოვნას ჯერ `loggingInterceptor` დაამუშავებს და შემდეგ ამ მოთხოვნას გადასცემს
`cachingIntercepor`-ს.

## პასუხის მოვლენების მოხელთება

გარდა გამავალი მოთხოვნებისა, ინტერცეპტორის საშუალებით ჩვენ შეგვიძლია მოვიხელთოთ HTTP მოთხოვნებისგან მიღებული პასუხებიც.
ეს შეიძლება იმისთვის დაგვჭირდეს, რომ აპლიკაციაში მოლოდინის რეჟიმი სათანადოდ ავსახოთ,
ან შედეგები სადმე შევინახოთ.

შემომავალ პასუხზე წვდომა გვაქვს უშუალოდ `next` ფუნქციაში, რომელიც არის `Observable`.
ამ შემთხვევაში ჩვენ მოვლენას ვიღებთ და მის შესახებ ინფორმაციას ვლოგავთ კონსოლში.
ვინაიდან ეს სტრიმი შეიცავს ყველა პასუხის მოვლენას, შესაძლოა საჭირო იყოს თითოეული
მოვლენის `.type`-ის შემოწმება რათა საბოლოო პასუხის ობიექტი ამოვიცნოთ.

```ts
export function loggingInterceptor(
  req: HttpRequest<unknown>,
  next: HttpHandlerFn
): Observable<HttpEvent<unknown>> {
  return next(req).pipe(
    tap((event) => {
      if (event.type === HttpEventType.Response) {
        console.log(req.url, "returned a response with status", event.status);
      }
    })
  );
}
```

## მოთხოვნების მოდიფიკაცია

ინტერცეპტორში ხელმისაწვდომი `HttpRequest` და `HttpResponse`-ის ინტანციები
არის უმეტესწილად არამოდიფიცირებადი (immutable), ამიტომ მათ უშუალოდ ვერ გარდავქმნით.
ამიტომ მათზე მანიპულაციების ჩასატარებლად საჭიროა მათი კლონირება `.clone()` მეთოდით.
ამ მეთოდში ჩვენ მივუთითებთ კონკრეტულად რა თვისებების შეცვლა გვსურს ახალ ინსტანციაზე.

მაგალითად, ჰედერების დასამატებლად:

```ts
const reqWithHeader = req.clone({
  headers: req.headers.set("X-New-Header", "new header value"),
});
```

ვინაიდან მოთხოვნების მუტაცია შეუძლებელია, ინტერცეპტორთა უმეტესობა იქნება იდემპოტენტური,
როცა `HttpRequest` მრავალჯერ მიეწოდება ინტერცეპტორთა ჯაჭვს. ეს შეიძლება მაშინ მოხდეს,
როცა წარუმატებელი მოთხოვნის რამდიმეჯერ გაგზავნის მცდელობა გვაქვს.

## Dependency Injection ინტერცეპტორებში

ვინაიდან ინტერცეპტორები მუშაობენ იმ ინჯექტორის injection context-ში, სადაც ისინი დარეგისტრირდნენ,
ეს საშუალებას გვაძლევს, გამოვიყენოთ ანგულარის `inject` ფუნქცია.

მაგალითად, თუ გვსურს, რომ გამოვიყენოთ ავთენტიკაციის სერვისი, რომელიც ქმნის ტოკენებს გამავალი მოთხოვნებისთვის,
ჩვენ ამ სერვისს უბრალოდ დავაინჯექთებთ ინტერცეპტორის ფუნქციაში:

```ts
export function authInterceptor(req: HttpRequest<unknown>, next: HttpHandlerFn) {
  // დავაინჯექთოთ `AuthService` და დავუძახოთ მასზე ტოკენის აღების მეთოდს:
  const authToken = inject(AuthService).getAuthToken();
  // დავკლონოთ მოთხოვნა რათა მას ავთენტიკაციის ჰედერზე ტოკენი დავუყენოთ.
  const newReq = req.clone({headers: {
    req.headers.append('X-Authentication-Token', authToken),
  }});
  return next(newReq);
}
```
